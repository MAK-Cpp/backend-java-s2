# Домашнее задание №2
## Задача 1

Для получения информации об обновлениях нам потребуются **HTTP**-клиенты для **GitHub** и **StackOverflow** в модуле **scrapper**.

Создание (современных) клиентов в Spring Boot возможно 2 способами: [WebClient](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#io.rest-client.webclient) и [HttpExchange](https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-http-interface).

После создания зарегистрируйте клиентов как бины в отдельном файле **`ClientConfiguration`** при помощи аннотации **`@Bean`**.

##### Ограничения:

1. Запрещается использовать **`RestTemplate`** или готовые **SDK** для доступа к **API**.
2. При создании клиента обязательно должна быть возможность указать базовый **URL**. При этом если он не указывается, то должен использоваться **URL** по умолчанию.
3. В ***Response**-классах для хранения времени должен использоваться класс **`OffsetDateTime`**.

_Подсказка: часто API возвращает слишком много данных. Можно пропустить их объявление в DTO-классе, тогда лишние поля будут проигнорированы._

Например, если бы мне потребовалось создать клиента для сайта **Gitlab**, который возвращает информацию о пользователе, то его интерфейс мог бы выглядеть следующим образом:
```java
interface GitlabClient {
  UserResponse fetchUser(String user);
}
```
###### **Клиент GitHub**

Создайте клиент **`GitHubClient`** любым удобным для вас способом.

Вам потребуется изучить [API-документацию](https://docs.github.com/en/rest) и найти нужный метод для получения информации из репозитория.

###### **Клиент StackOverflow**

Создайте клиент **`StackOverflowClient`** любым удобным для вас способом.

Вам потребуется изучить [API-документацию](https://api.stackexchange.com/docs) и найти нужный метод для получения информации о вопросе (передаётся номер вопроса).



## Задача 2

Протестируйте клиентов при помощи библиотеки [WireMock](https://wiremock.org/) (зависимость уже добавлена).



## Задача 3

В работе сервисов иногда приходится прибегать к механизму фоновых задач. Почти всегда это какие-то простые сценарии, не требующие сложной логики, например, обновить данные в кэше или проверить состояние чего-либо.

В нашей задаче требуется периодически ходить по ссылкам из БД и проверять не появились ли обновления.

1. Создайте класс **`LinkUpdaterScheduler`** с единственным методом **`update`** и добавьте логирование-заглушку в тело метода.
2. Включите поддержку **`@Schedule`***-аннотаций при помощи **`@EnableScheduling`**.
3. Сделайте метод **`update`** запланированным (**`@Scheduled`**).
4. Добавьте в **`ApplicationConfig`** поле **`scheduler`** типа **`record Scheduler(Duration interval)`**.
5. В **application.properties/yaml** создайте ключ **app.scheduler.interval** и задайте ему какое-нибудь значение (5-15с).
6. Сделайте так, чтобы аннотация **`@Scheduled`** на методе **`update`** инициализировала значение **`delay`** из конфигурации.

_Подсказка:_ **_`@Scheduled`_**_-аннотация поддерживает_ [**_SpEL_**](https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/core.html#expressions) _-- возможность обращения к контексту_ **_Spring_** _через специальный синтаксис, например:_

`@Scheduled(fixedDelayString = "#{@beanName}")`
